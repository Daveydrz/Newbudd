"""
Calendar Monitor System - Autonomous Pattern Recognition & Proactive Scheduling

This module implements an intelligent calendar monitoring system that:
- Continuously monitors time patterns and schedules
- Proactively warns about upcoming tasks and deadlines
- Recognizes behavioral patterns and suggests optimizations
- Provides contextual reminders based on user habits
- Integrates with consciousness for natural reminder delivery
"""

import threading
import time
import logging
from typing import Dict, List, Any, Optional, Callable
from dataclasses import dataclass, field
from datetime import datetime, timedelta, date
from enum import Enum
import json
import calendar
import re

class ReminderType(Enum):
    """Types of reminders and notifications"""
    UPCOMING_TASK = "upcoming_task"
    DEADLINE_WARNING = "deadline_warning"
    PATTERN_SUGGESTION = "pattern_suggestion"
    HABIT_REMINDER = "habit_reminder"
    TIME_AWARENESS = "time_awareness"
    SCHEDULE_CONFLICT = "schedule_conflict"
    BREAK_SUGGESTION = "break_suggestion"
    PRODUCTIVITY_INSIGHT = "productivity_insight"

class PatternType(Enum):
    """Types of behavioral patterns"""
    DAILY_ROUTINE = "daily_routine"
    WEEKLY_PATTERN = "weekly_pattern"
    WORK_HABITS = "work_habits"
    BREAK_PATTERNS = "break_patterns"
    COMMUNICATION_TIMING = "communication_timing"
    PRODUCTIVITY_CYCLES = "productivity_cycles"

@dataclass
class CalendarEvent:
    """A calendar event or task"""
    title: str
    start_time: datetime
    end_time: Optional[datetime] = None
    description: str = ""
    location: str = ""
    priority: int = 1  # 1-5 scale
    tags: List[str] = field(default_factory=list)
    reminder_times: List[int] = field(default_factory=list)  # minutes before
    is_recurring: bool = False
    recurrence_pattern: str = ""

@dataclass
class BehaviorPattern:
    """Detected behavioral pattern"""
    pattern_type: PatternType
    description: str
    frequency: float  # How often this pattern occurs (0.0-1.0)
    confidence: float  # Confidence in pattern detection (0.0-1.0)
    optimal_times: List[tuple[int, int]]  # (hour, minute) pairs
    conditions: Dict[str, Any]
    suggestions: List[str]
    last_observed: datetime

@dataclass
class ProactiveReminder:
    """A proactive reminder generated by the system"""
    content: str
    reminder_type: ReminderType
    priority: float
    timestamp: datetime
    trigger_time: datetime
    should_speak: bool = True
    context: Dict[str, Any] = None

class CalendarMonitorSystem:
    """
    Autonomous calendar and pattern monitoring system.
    
    This system:
    - Continuously monitors time and schedules
    - Detects behavioral patterns and habits
    - Generates proactive reminders and suggestions
    - Integrates with consciousness for natural delivery
    - Learns from user interactions to improve suggestions
    """
    
    def __init__(self, save_path: str = "ai_calendar_monitor.json"):
        # Core data
        self.events: List[CalendarEvent] = []
        self.patterns: List[BehaviorPattern] = []
        self.reminders: List[ProactiveReminder] = []
        self.save_path = save_path
        
        # Pattern detection
        self.interaction_history: List[Dict[str, Any]] = []
        self.time_awareness_intervals = [15, 30, 60, 120]  # minutes
        self.pattern_confidence_threshold = 0.6
        
        # Monitoring parameters
        self.check_interval = 60.0  # seconds between checks
        self.reminder_lookahead = 24 * 60  # minutes to look ahead for reminders
        self.pattern_detection_window = 14  # days for pattern analysis
        
        # Consciousness integration
        self.consciousness_modules = {}
        self.voice_system = None
        self.llm_handler = None
        
        # Threading
        self.lock = threading.Lock()
        self.monitor_thread = None
        self.running = False
        
        # Current state
        self.last_reminder_check = datetime.now()
        self.last_pattern_analysis = datetime.now()
        self.current_context = {}
        
        self._load_data()
        self._initialize_default_patterns()
        
        logging.info("[CalendarMonitor] üìÖ Calendar monitoring system initialized")
    
    def start(self):
        """Start the calendar monitoring system"""
        if self.running:
            return
        
        self.running = True
        self.monitor_thread = threading.Thread(target=self._monitoring_loop, daemon=True)
        self.monitor_thread.start()
        logging.info("[CalendarMonitor] ‚úÖ Calendar monitoring started")
    
    def stop(self):
        """Stop the monitoring system"""
        self.running = False
        if self.monitor_thread:
            self.monitor_thread.join(timeout=2.0)
        self._save_data()
        logging.info("[CalendarMonitor] üõë Calendar monitoring stopped")
    
    def register_consciousness_module(self, name: str, module: Any):
        """Register consciousness module for integration"""
        with self.lock:
            self.consciousness_modules[name] = module
    
    def register_voice_system(self, voice_system: Any):
        """Register voice system for spoken reminders"""
        self.voice_system = voice_system
    
    def register_llm_handler(self, llm_handler: Any):
        """Register LLM handler for intelligent reminder generation"""
        self.llm_handler = llm_handler
    
    def register_voice_system(self, voice_system: Any):
        """Register voice system (not used directly by calendar monitor but provided for interface consistency)"""
        pass  # Calendar monitor doesn't directly use voice system
    
    def add_event(self, event: CalendarEvent):
        """Add a calendar event"""
        with self.lock:
            self.events.append(event)
        self._analyze_event_patterns()
        logging.info(f"[CalendarMonitor] üìù Added event: {event.title}")
    
    def record_interaction(self, interaction_type: str, context: Dict[str, Any]):
        """Record user interaction for pattern analysis"""
        interaction = {
            'type': interaction_type,
            'timestamp': datetime.now(),
            'context': context,
            'day_of_week': datetime.now().weekday(),
            'hour': datetime.now().hour,
            'minute': datetime.now().minute
        }
        
        with self.lock:
            self.interaction_history.append(interaction)
            # Keep last 1000 interactions
            if len(self.interaction_history) > 1000:
                self.interaction_history = self.interaction_history[-1000:]
    
    def update_context(self, context: Dict[str, Any]):
        """Update current context for pattern recognition"""
        with self.lock:
            self.current_context.update(context)
    
    def _monitoring_loop(self):
        """Main monitoring loop"""
        while self.running:
            try:
                current_time = datetime.now()
                
                # Check for upcoming events and generate reminders
                if (current_time - self.last_reminder_check).total_seconds() >= 60:
                    self._check_upcoming_events()
                    self._generate_time_awareness_reminders()
                    self.last_reminder_check = current_time
                
                # Analyze patterns periodically
                if (current_time - self.last_pattern_analysis).total_seconds() >= 3600:  # hourly
                    self._analyze_behavior_patterns()
                    self.last_pattern_analysis = current_time
                
                # Process pending reminders
                self._process_pending_reminders()
                
                time.sleep(self.check_interval)
                
            except Exception as e:
                logging.error(f"[CalendarMonitor] ‚ùå Error in monitoring loop: {e}")
                time.sleep(60.0)  # Error recovery
    
    def _check_upcoming_events(self):
        """Check for upcoming events and generate reminders"""
        current_time = datetime.now()
        lookahead_time = current_time + timedelta(minutes=self.reminder_lookahead)
        
        for event in self.events:
            if current_time <= event.start_time <= lookahead_time:
                # Generate reminders based on event reminder times
                for reminder_minutes in event.reminder_times:
                    reminder_time = event.start_time - timedelta(minutes=reminder_minutes)
                    
                    if current_time <= reminder_time <= current_time + timedelta(minutes=5):
                        reminder = self._create_event_reminder(event, reminder_minutes)
                        if reminder:
                            self._add_reminder(reminder)
    
    def _generate_time_awareness_reminders(self):
        """Generate time awareness and productivity reminders"""
        current_time = datetime.now()
        
        # Check for pattern-based suggestions
        relevant_patterns = self._get_relevant_patterns(current_time)
        
        for pattern in relevant_patterns:
            if pattern.pattern_type == PatternType.PRODUCTIVITY_CYCLES:
                suggestion = self._generate_productivity_suggestion(pattern, current_time)
                if suggestion:
                    self._add_reminder(suggestion)
            
            elif pattern.pattern_type == PatternType.BREAK_PATTERNS:
                break_reminder = self._generate_break_reminder(pattern, current_time)
                if break_reminder:
                    self._add_reminder(break_reminder)
    
    def _analyze_behavior_patterns(self):
        """Analyze user behavior to detect patterns"""
        if len(self.interaction_history) < 10:
            return
        
        # Analyze different pattern types
        self._analyze_daily_routine_patterns()
        self._analyze_productivity_patterns()
        self._analyze_communication_patterns()
        self._analyze_break_patterns()
        
        logging.info(f"[CalendarMonitor] üîç Analyzed patterns, found {len(self.patterns)} patterns")
    
    def _analyze_daily_routine_patterns(self):
        """Analyze daily routine patterns"""
        # Group interactions by hour and day of week
        hour_patterns = {}
        
        cutoff_date = datetime.now() - timedelta(days=self.pattern_detection_window)
        recent_interactions = [
            i for i in self.interaction_history 
            if i['timestamp'] > cutoff_date
        ]
        
        for interaction in recent_interactions:
            hour = interaction['hour']
            day_of_week = interaction['day_of_week']
            
            key = (day_of_week, hour)
            if key not in hour_patterns:
                hour_patterns[key] = []
            hour_patterns[key].append(interaction)
        
        # Find consistent patterns
        for (day_of_week, hour), interactions in hour_patterns.items():
            if len(interactions) >= 3:  # Minimum occurrences
                frequency = len(interactions) / max(1, self.pattern_detection_window)
                
                if frequency > 0.3:  # At least 30% of days
                    pattern = BehaviorPattern(
                        pattern_type=PatternType.DAILY_ROUTINE,
                        description=f"Regular activity on {calendar.day_name[day_of_week]} at {hour}:00",
                        frequency=frequency,
                        confidence=min(frequency * 2, 1.0),
                        optimal_times=[(hour, 0)],
                        conditions={'day_of_week': day_of_week, 'hour': hour},
                        suggestions=[f"Consider scheduling important tasks around {hour}:00 on {calendar.day_name[day_of_week]}"],
                        last_observed=max(i['timestamp'] for i in interactions)
                    )
                    self._update_pattern(pattern)
    
    def _analyze_productivity_patterns(self):
        """Analyze productivity and work patterns"""
        work_interactions = [
            i for i in self.interaction_history 
            if i['type'] in ['work_task', 'coding', 'writing', 'problem_solving']
        ]
        
        if len(work_interactions) < 5:
            return
        
        # Analyze productivity by hour
        productivity_by_hour = {}
        for interaction in work_interactions:
            hour = interaction['hour']
            if hour not in productivity_by_hour:
                productivity_by_hour[hour] = []
            productivity_by_hour[hour].append(interaction)
        
        # Find peak productivity hours
        peak_hours = []
        for hour, interactions in productivity_by_hour.items():
            if len(interactions) >= 3:
                peak_hours.append((hour, len(interactions)))
        
        if peak_hours:
            peak_hours.sort(key=lambda x: x[1], reverse=True)
            top_hours = [hour for hour, count in peak_hours[:3]]
            
            pattern = BehaviorPattern(
                pattern_type=PatternType.PRODUCTIVITY_CYCLES,
                description=f"Peak productivity hours: {', '.join(f'{h}:00' for h in top_hours)}",
                frequency=len(work_interactions) / max(len(self.interaction_history), 1),
                confidence=0.8,
                optimal_times=[(hour, 0) for hour in top_hours],
                conditions={'productivity_peak': True},
                suggestions=[
                    f"Consider scheduling important work during {top_hours[0]}:00-{top_hours[0]+1}:00",
                    "Avoid scheduling meetings during peak productivity hours"
                ],
                last_observed=datetime.now()
            )
            self._update_pattern(pattern)
    
    def _analyze_communication_patterns(self):
        """Analyze communication timing patterns"""
        comm_interactions = [
            i for i in self.interaction_history 
            if i['type'] in ['conversation', 'message', 'call', 'meeting']
        ]
        
        if len(comm_interactions) < 5:
            return
        
        # Analyze communication timing
        comm_hours = [i['hour'] for i in comm_interactions]
        
        # Find most common communication hours
        hour_counts = {}
        for hour in comm_hours:
            hour_counts[hour] = hour_counts.get(hour, 0) + 1
        
        if hour_counts:
            common_hours = sorted(hour_counts.keys(), key=lambda h: hour_counts[h], reverse=True)[:3]
            
            pattern = BehaviorPattern(
                pattern_type=PatternType.COMMUNICATION_TIMING,
                description=f"Preferred communication hours: {', '.join(f'{h}:00' for h in common_hours)}",
                frequency=len(comm_interactions) / max(len(self.interaction_history), 1),
                confidence=0.7,
                optimal_times=[(hour, 0) for hour in common_hours],
                conditions={'communication_optimal': True},
                suggestions=[
                    f"Best time for important communications: {common_hours[0]}:00",
                    "Schedule meetings during preferred communication hours"
                ],
                last_observed=datetime.now()
            )
            self._update_pattern(pattern)
    
    def _analyze_break_patterns(self):
        """Analyze break and rest patterns"""
        # Look for gaps in activity that might indicate break patterns
        sorted_interactions = sorted(self.interaction_history, key=lambda x: x['timestamp'])
        
        break_periods = []
        for i in range(1, len(sorted_interactions)):
            time_gap = (sorted_interactions[i]['timestamp'] - sorted_interactions[i-1]['timestamp']).total_seconds() / 60
            
            if 15 <= time_gap <= 120:  # 15 minutes to 2 hours could be breaks
                break_periods.append({
                    'duration': time_gap,
                    'start_hour': sorted_interactions[i-1]['hour'],
                    'end_hour': sorted_interactions[i]['hour'],
                    'day_of_week': sorted_interactions[i-1]['day_of_week']
                })
        
        if len(break_periods) >= 5:
            # Find common break times
            break_hours = [bp['start_hour'] for bp in break_periods]
            hour_counts = {}
            for hour in break_hours:
                hour_counts[hour] = hour_counts.get(hour, 0) + 1
            
            common_break_hours = [h for h, count in hour_counts.items() if count >= 2]
            
            if common_break_hours:
                pattern = BehaviorPattern(
                    pattern_type=PatternType.BREAK_PATTERNS,
                    description=f"Common break times: {', '.join(f'{h}:00' for h in common_break_hours)}",
                    frequency=len(break_periods) / max(len(self.interaction_history), 1),
                    confidence=0.6,
                    optimal_times=[(hour, 0) for hour in common_break_hours],
                    conditions={'break_optimal': True},
                    suggestions=[
                        "Consider taking regular breaks during these times",
                        "Schedule short breaks to maintain productivity"
                    ],
                    last_observed=datetime.now()
                )
                self._update_pattern(pattern)
    
    def _get_relevant_patterns(self, current_time: datetime) -> List[BehaviorPattern]:
        """Get patterns relevant to current time and context"""
        relevant = []
        
        current_hour = current_time.hour
        current_day = current_time.weekday()
        
        for pattern in self.patterns:
            # Check if pattern applies to current time
            is_relevant = False
            
            for opt_hour, opt_minute in pattern.optimal_times:
                # Check if we're within 1 hour of optimal time
                if abs(current_hour - opt_hour) <= 1:
                    is_relevant = True
                    break
            
            # Check day-specific patterns
            if 'day_of_week' in pattern.conditions:
                if pattern.conditions['day_of_week'] == current_day:
                    is_relevant = True
            
            if is_relevant and pattern.confidence >= self.pattern_confidence_threshold:
                relevant.append(pattern)
        
        return relevant
    
    def _create_event_reminder(self, event: CalendarEvent, minutes_before: int) -> Optional[ProactiveReminder]:
        """Create a reminder for an upcoming event"""
        time_str = "now" if minutes_before == 0 else f"in {minutes_before} minutes"
        
        content = f"Reminder: {event.title} starts {time_str}"
        if event.location:
            content += f" at {event.location}"
        
        return ProactiveReminder(
            content=content,
            reminder_type=ReminderType.UPCOMING_TASK,
            priority=0.8 + (event.priority * 0.04),  # Scale priority
            timestamp=datetime.now(),
            trigger_time=event.start_time - timedelta(minutes=minutes_before),
            should_speak=True,
            context={
                'event': event.title,
                'minutes_before': minutes_before,
                'event_priority': event.priority
            }
        )
    
    def _generate_productivity_suggestion(self, pattern: BehaviorPattern, current_time: datetime) -> Optional[ProactiveReminder]:
        """Generate productivity suggestion based on pattern"""
        if pattern.pattern_type != PatternType.PRODUCTIVITY_CYCLES:
            return None
        
        current_hour = current_time.hour
        optimal_hours = [hour for hour, minute in pattern.optimal_times]
        
        if current_hour in optimal_hours:
            content = "This is typically one of your most productive hours. Consider tackling important tasks now."
            
            return ProactiveReminder(
                content=content,
                reminder_type=ReminderType.PRODUCTIVITY_INSIGHT,
                priority=0.6,
                timestamp=datetime.now(),
                trigger_time=current_time,
                should_speak=True,
                context={
                    'pattern_type': pattern.pattern_type.value,
                    'optimal_hour': current_hour,
                    'confidence': pattern.confidence
                }
            )
        
        return None
    
    def _generate_break_reminder(self, pattern: BehaviorPattern, current_time: datetime) -> Optional[ProactiveReminder]:
        """Generate break reminder based on pattern"""
        if pattern.pattern_type != PatternType.BREAK_PATTERNS:
            return None
        
        current_hour = current_time.hour
        break_hours = [hour for hour, minute in pattern.optimal_times]
        
        if current_hour in break_hours:
            content = "Based on your patterns, this might be a good time for a short break."
            
            return ProactiveReminder(
                content=content,
                reminder_type=ReminderType.BREAK_SUGGESTION,
                priority=0.4,
                timestamp=datetime.now(),
                trigger_time=current_time,
                should_speak=True,
                context={
                    'pattern_type': pattern.pattern_type.value,
                    'break_hour': current_hour,
                    'frequency': pattern.frequency
                }
            )
        
        return None
    
    def _update_pattern(self, new_pattern: BehaviorPattern):
        """Update or add a behavioral pattern"""
        with self.lock:
            # Check if similar pattern exists
            existing_pattern = None
            for i, pattern in enumerate(self.patterns):
                if (pattern.pattern_type == new_pattern.pattern_type and 
                    pattern.conditions == new_pattern.conditions):
                    existing_pattern = i
                    break
            
            if existing_pattern is not None:
                # Update existing pattern
                self.patterns[existing_pattern] = new_pattern
            else:
                # Add new pattern
                self.patterns.append(new_pattern)
                # Limit number of patterns
                if len(self.patterns) > 50:
                    self.patterns = self.patterns[-50:]
    
    def _add_reminder(self, reminder: ProactiveReminder):
        """Add a reminder to the queue"""
        with self.lock:
            # Check for duplicate reminders
            for existing in self.reminders:
                if (existing.content == reminder.content and 
                    abs((existing.timestamp - reminder.timestamp).total_seconds()) < 300):
                    return  # Skip duplicate
            
            self.reminders.append(reminder)
    
    def _process_pending_reminders(self):
        """Process and deliver pending reminders"""
        current_time = datetime.now()
        
        with self.lock:
            due_reminders = [
                r for r in self.reminders 
                if r.trigger_time <= current_time
            ]
            
            # Remove due reminders from queue
            self.reminders = [
                r for r in self.reminders 
                if r.trigger_time > current_time
            ]
        
        # Deliver reminders
        for reminder in due_reminders:
            self._deliver_reminder(reminder)
    
    def _deliver_reminder(self, reminder: ProactiveReminder):
        """Deliver a reminder through appropriate channels"""
        try:
            # Speak reminder if voice system available
            if reminder.should_speak and self.voice_system:
                spoken_content = self._format_reminder_for_speech(reminder)
                
                if hasattr(self.voice_system, 'speak_streaming'):
                    self.voice_system.speak_streaming(spoken_content)
                elif hasattr(self.voice_system, 'speak_async'):
                    self.voice_system.speak_async(spoken_content)
            
            # Integrate with consciousness modules
            self._integrate_reminder_with_consciousness(reminder)
            
            logging.info(f"[CalendarMonitor] üì¢ Delivered reminder: {reminder.content}")
            
        except Exception as e:
            logging.error(f"[CalendarMonitor] ‚ùå Reminder delivery error: {e}")
    
    def _format_reminder_for_speech(self, reminder: ProactiveReminder) -> str:
        """Format reminder content for natural speech"""
        if reminder.reminder_type == ReminderType.UPCOMING_TASK:
            return f"Hey, just a heads up: {reminder.content}"
        elif reminder.reminder_type == ReminderType.PRODUCTIVITY_INSIGHT:
            return f"You know, {reminder.content}"
        elif reminder.reminder_type == ReminderType.BREAK_SUGGESTION:
            return f"I notice that {reminder.content}"
        elif reminder.reminder_type == ReminderType.TIME_AWARENESS:
            return f"By the way, {reminder.content}"
        else:
            return reminder.content
    
    def _integrate_reminder_with_consciousness(self, reminder: ProactiveReminder):
        """Integrate reminder with consciousness modules"""
        try:
            # Add to global workspace if available
            if 'global_workspace' in self.consciousness_modules:
                gw = self.consciousness_modules['global_workspace']
                if hasattr(gw, 'request_attention'):
                    from ai.global_workspace import AttentionPriority, ProcessingMode
                    
                    priority_map = {
                        ReminderType.UPCOMING_TASK: AttentionPriority.HIGH,
                        ReminderType.DEADLINE_WARNING: AttentionPriority.CRITICAL,
                        ReminderType.PRODUCTIVITY_INSIGHT: AttentionPriority.MEDIUM,
                        ReminderType.BREAK_SUGGESTION: AttentionPriority.LOW
                    }
                    
                    priority = priority_map.get(reminder.reminder_type, AttentionPriority.MEDIUM)
                    
                    gw.request_attention(
                        "calendar_monitor",
                        reminder.content,
                        priority,
                        ProcessingMode.CONSCIOUS,
                        tags=[reminder.reminder_type.value, "calendar", "reminder"]
                    )
            
            # Trigger motivation if relevant
            if 'motivation_system' in self.consciousness_modules:
                ms = self.consciousness_modules['motivation_system']
                if hasattr(ms, 'process_external_trigger'):
                    ms.process_external_trigger(reminder.content, reminder.context)
            
        except Exception as e:
            logging.error(f"[CalendarMonitor] ‚ùå Consciousness integration error: {e}")
    
    def _initialize_default_patterns(self):
        """Initialize default behavioral patterns"""
        # These are common patterns that can be detected
        default_patterns = [
            {
                'type': PatternType.DAILY_ROUTINE,
                'description': 'Morning productivity peak',
                'hours': [8, 9, 10],
                'frequency': 0.7,
                'suggestions': ['Schedule important tasks in the morning', 'Avoid meetings during peak hours']
            },
            {
                'type': PatternType.BREAK_PATTERNS,
                'description': 'Mid-afternoon break',
                'hours': [14, 15],
                'frequency': 0.5,
                'suggestions': ['Take a short break around 3 PM', 'Consider a walk or coffee break']
            }
        ]
        
        # These will be updated as real patterns are detected
        logging.info("[CalendarMonitor] üìã Initialized default pattern templates")
    
    def _save_data(self):
        """Save calendar data and patterns"""
        try:
            data = {
                'events': [],
                'patterns': [],
                'interaction_history': [],
                'last_save': datetime.now().isoformat()
            }
            
            # Serialize events
            for event in self.events:
                data['events'].append({
                    'title': event.title,
                    'start_time': event.start_time.isoformat(),
                    'end_time': event.end_time.isoformat() if event.end_time else None,
                    'description': event.description,
                    'location': event.location,
                    'priority': event.priority,
                    'tags': event.tags,
                    'reminder_times': event.reminder_times,
                    'is_recurring': event.is_recurring,
                    'recurrence_pattern': event.recurrence_pattern
                })
            
            # Serialize patterns
            for pattern in self.patterns:
                data['patterns'].append({
                    'pattern_type': pattern.pattern_type.value,
                    'description': pattern.description,
                    'frequency': pattern.frequency,
                    'confidence': pattern.confidence,
                    'optimal_times': pattern.optimal_times,
                    'conditions': pattern.conditions,
                    'suggestions': pattern.suggestions,
                    'last_observed': pattern.last_observed.isoformat()
                })
            
            # Serialize recent interaction history
            cutoff = datetime.now() - timedelta(days=30)
            recent_interactions = []
            for i in self.interaction_history:
                # Handle both datetime objects and string timestamps
                timestamp = i['timestamp']
                if isinstance(timestamp, str):
                    timestamp = datetime.fromisoformat(timestamp)
                
                if timestamp > cutoff:
                    recent_interactions.append({
                        'type': i['type'],
                        'timestamp': timestamp.isoformat(),
                        'context': i['context'],
                        'day_of_week': i['day_of_week'],
                        'hour': i['hour'],
                        'minute': i['minute']
                    })
            
            data['interaction_history'] = recent_interactions
            
            with open(self.save_path, 'w') as f:
                json.dump(data, f, indent=2)
                
        except Exception as e:
            logging.error(f"[CalendarMonitor] ‚ùå Save error: {e}")
    
    def _load_data(self):
        """Load calendar data and patterns"""
        try:
            with open(self.save_path, 'r') as f:
                data = json.load(f)
            
            # Load events
            self.events = []
            for event_data in data.get('events', []):
                event = CalendarEvent(
                    title=event_data['title'],
                    start_time=datetime.fromisoformat(event_data['start_time']),
                    end_time=datetime.fromisoformat(event_data['end_time']) if event_data.get('end_time') else None,
                    description=event_data.get('description', ''),
                    location=event_data.get('location', ''),
                    priority=event_data.get('priority', 1),
                    tags=event_data.get('tags', []),
                    reminder_times=event_data.get('reminder_times', []),
                    is_recurring=event_data.get('is_recurring', False),
                    recurrence_pattern=event_data.get('recurrence_pattern', '')
                )
                self.events.append(event)
            
            # Load patterns
            self.patterns = []
            for pattern_data in data.get('patterns', []):
                pattern = BehaviorPattern(
                    pattern_type=PatternType(pattern_data['pattern_type']),
                    description=pattern_data['description'],
                    frequency=pattern_data['frequency'],
                    confidence=pattern_data['confidence'],
                    optimal_times=pattern_data['optimal_times'],
                    conditions=pattern_data['conditions'],
                    suggestions=pattern_data['suggestions'],
                    last_observed=datetime.fromisoformat(pattern_data['last_observed'])
                )
                self.patterns.append(pattern)
            
            # Load interaction history
            self.interaction_history = []
            for interaction_data in data.get('interaction_history', []):
                interaction = {
                    'type': interaction_data['type'],
                    'timestamp': datetime.fromisoformat(interaction_data['timestamp']),
                    'context': interaction_data['context'],
                    'day_of_week': interaction_data['day_of_week'],
                    'hour': interaction_data['hour'],
                    'minute': interaction_data['minute']
                }
                self.interaction_history.append(interaction)
            
            logging.info(f"[CalendarMonitor] üìö Loaded {len(self.events)} events, {len(self.patterns)} patterns, {len(self.interaction_history)} interactions")
            
        except FileNotFoundError:
            logging.info("[CalendarMonitor] üìù No previous data found, starting fresh")
        except Exception as e:
            logging.error(f"[CalendarMonitor] ‚ùå Load error: {e}")
    
    def get_stats(self) -> Dict[str, Any]:
        """Get calendar monitoring statistics"""
        with self.lock:
            return {
                'total_events': len(self.events),
                'total_patterns': len(self.patterns),
                'interaction_history_size': len(self.interaction_history),
                'pending_reminders': len(self.reminders),
                'running': self.running,
                'pattern_types': [p.pattern_type.value for p in self.patterns],
                'high_confidence_patterns': len([p for p in self.patterns if p.confidence > 0.7]),
                'last_pattern_analysis': self.last_pattern_analysis.isoformat(),
                'consciousness_modules': list(self.consciousness_modules.keys())
            }


# Global instance
calendar_monitor_system = CalendarMonitorSystem()